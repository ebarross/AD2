---
title: "Deep Learning com Keras"
author: "Emanoel Barros"
date: "12 de março de 2018"
output: html_document
---
<p></p>
O objetivo desse lab é o de auto-aprendizagem em uma ferramenta de deep learning. Em particular vamos aprender a implementar e interpretar uma rede do tipo multilayer perceptron (MLP) em R e Keras, um framework de deep learning.

Para isso você deve:

Ler o tutorial: https://www.datacamp.com/community/tutorials/keras-r-deep-learning (Links para um site externo)Links para um site externo
Implementar os passos descritos no tutorial e organizá-los em um RMD com seus próprios comentários em português. A tarefa é basicamente reescrever o tutorial com suas próprias palavras, em português, e eventualmente de forma mais sucinta já o que o tutorial original é bastante extenso. Você pode adicionar explicações, código e dados que não estão no tutorial original, na verdade você é encorajado a fazer isso.
Os critérios para correção serão:
Facilidade em seguir o seu tutorial
Se o código executa corretamente
Bônus: Testar MLP na predição de votação do lab anterior e reportar o resultado.

A entrega deve ser o envio do .Rmd e publicação no Rpubs. Quando for publicar no Rpubs não esquecer de fazer referência ao tutorial original.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<p><b>Keras</b> é um pacote que oferece funções para o estudo sobre modelos abordando <i>deep learning</i> no R.</p>

<p>Esse tutorial terá como foco o MLP (Multi-Layer Perceptron), um tipo de Rede Neural Artificial que possui pelo menos três camadas internas compostas por nós (neurônios).</p>

<h3>Instalando o pacote</h3>

<p>Primeiro, importaremos o pacote <b>devtools</b> para poder instalar os pacotes que serão necessários:</p>
```{r warning=FALSE, message=FALSE}
library(devtools)
```

<p>Em seguida, são importados o <b>keras</b> e <b>tensorflow</b>, para isso é necessário tê-los instalados:</p>
```{r warning=FALSE, message=FALSE}
# install_github("rstudio/tensorflow")
# install_github("rstudio/keras")

library(keras)
library(tensorflow)

# install_keras()
```

<h3>Carregando os dados</h3>

<p>Os dados podem ser carregados de 3 maneiras diferentes:</p>

<p>Utilizando os datasets do keras:</p>
```{r}
mnist <- dataset_mnist()

cifar10 <- dataset_cifar10()

imdb <- dataset_imdb()
```

<p>Criando nosso próprio dataset com dados aleatórios a partir da função <b>matrix()</b>:</p>
```{r}
dados <- matrix(rexp(1000*784), nrow = 1000, ncol = 784)

labels <- matrix(round(runif(1000 * 10, min = 0, max = 9)),
                 nrow = 1000, ncol = 10)
```

<p>Importando de um arquivo CSV (ou outro formato):</p>
```{r}
# Carregando o arquivo na variável iris: 
iris <- read.csv(url("http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"), header = FALSE)

# Cabeçalho do dataset
head(iris)

# Estrutura
str(iris)

# Dimensões
dim(iris)
```

<p>Utilizaremos esse dataset que contém dados sobre as dimensões de flores de íris e suas respectivas classificações. Mais detalhes em: http://archive.ics.uci.edu/ml/datasets/Iris</p>

<h3>Exploração dos dados</h3>

<p>É importante saber que todas as flores possuem <b>sépalas</b> e <b>pétalas</b>. Sépalas tem tipicamente um tom esverdeado, enquanto as pétalas são coloridas. Isso é diferente nas íris, como pode ser visto nas imagens:</p>

<img src="https://s3.amazonaws.com/assets.datacamp.com/blog_assets/iris-machinelearning.png">

<p>Adicionaremos nomes para as colunas com a função <b>names()</b> e utilizaremos a função <b>plot()</b> para visualizar a correlação entre o comprimento e a largura das pétalas:</p>
```{r}
# Atribuindo nomes às colunas
names(iris) <- c("Sepala.Comprimento", "Sepala.Largura", "Petala.Comprimento", "Petala.Largura", "Especie")

# Plotando o gráfico de correlação
plot(iris$Petala.Comprimento,
     iris$Petala.Largura,
     pch = 21,
     bg = c("red", "green3", "blue")[unclass(iris$Especie)],
     xlab = "Comprimento da Petala",
     ylab = "Largura da Petala")

# Correlação geral entre os dois atributos
cor(iris$Petala.Comprimento, iris$Petala.Largura)
```
<p>A função <b>unclass()</b> foi usada para mapear os nomes das espécies para valores numéricos (1, 2 e 3).</p>

<p>Pelo gráfico, é possível observar que há uma correlação significativa entre o comprimento e a largura da pétala e seu valor é de <b>0.9627571</b>.</p> 

<p>Precisamos verificar os outros atributos, para isso utilizamos a função <b>cor()</b> com todos os atributos. Além disso, utilizamos a função <b>corrplot()</b> do pacote de mesmo nome para ter uma melhor visão das correlações:</p>
```{r}
# Salvando a correção geral em M
M <- cor(iris[,1:4])

# Importando o pacote corrplot
library(corrplot)

# Plotando o gráfico de correlações com o método de círculos
corrplot(M, method = "circle")
```

<h3>Pré-processamento dos dados</h3>

<p>Antes de construírmos o modelo, é necessário termos certeza de que os dados estão limpos, normalizados e divididos entre <b>treino</b> e <b>teste</b>.</p>

<p>Como estamos fazendo uso de um dataset do UCI Machine Learning Repository, podemos esperar que esses dados já estejam prontos para uso, ou seja, limpos e normalizados. Checaremos isso a seguir.</p>

<h5>Normalizando os dados:</h5>

<p>Iremos utilizar a função <b>normalize()</b> do keras. Para isso, precisamos ter os dados dispostos em uma matriz:</p>
```{r}
# Convertendo os nomes das espécies em valores numéricos
iris[,5] <- as.numeric(iris[,5]) -1

# Convertendo os dados em uma matriz
iris <- as.matrix(iris)

# Excluindo os nomes das colunas
dimnames(iris) <- NULL

# Normalizando os dados
irisNormalizado <- normalize(iris[,1:4])

# Mostrando o sumário
summary(iris)
summary(irisNormalizado)
```

<h5>Separando os dados:</h5>

<p>Precisamos separar nosso dataset em treino e teste. Para isso, definimos um peso para cada uma das duas partições utilizando a função <b>sample()</b>:</p>
```{r}
# Define o tamanho das amostras
ind <- sample(2, nrow(iris), replace = TRUE, prob = c(0.67, 0.33))

# Divide os dados
iris.treino <- iris[ind==1, 1:4]
iris.teste <- iris[ind==2, 1:4]

# Divide o atributo de classificação
iris.treinoalvo <- iris[ind==1, 5]
iris.testealvo <- iris[ind==2, 5]
```

<h5>Codificação One-Hot</h5>

<p>Utilizaremos a função <b>to_categorical()</b> para converter os arrays com o atributo alvo para uma matriz de booleanos, que indica a qual classe pertence cada dado:</p>
```{r}
iris.treinoRotulos <- to_categorical(iris.treinoalvo)

iris.testeRotulos <- to_categorical(iris.testealvo)
```

<h3>Construindo o Modelo</h3>

<b></b>